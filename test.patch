diff --git a/Cargo.toml b/Cargo.toml
index 5c4cfe8..64b203b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -4,7 +4,7 @@ version = "1.31.0"
 description = "HTTP REST API caching middleware, to be used between load balancers and REST API workers."
 readme = "README.md"
 license = "MPL-2.0"
-edition = "2018"
+edition = "2021"
 homepage = "https://github.com/valeriansaliou/bloom"
 repository = "https://github.com/valeriansaliou/bloom.git"
 keywords = ["proxy", "http", "api", "rest", "cache"]
diff --git a/src/cache/read.rs b/src/cache/read.rs
index 1101c79..fc53425 100644
--- a/src/cache/read.rs
+++ b/src/cache/read.rs
@@ -21,10 +21,10 @@ pub enum CacheReadError {
 }
 
 type CacheReadResult = Result<String, CacheReadError>;
-type CacheReadResultFuture = Box<dyn Future<Item = CacheReadResult, Error = ()>>;
+type CacheReadResultFuture = Box<dyn Future<Output = CacheReadResult>>;
 
 type CacheReadOptionalResult = Result<Option<String>, CacheReadError>;
-type CacheReadOptionalResultFuture = Box<dyn Future<Item = CacheReadOptionalResult, Error = ()>>;
+type CacheReadOptionalResultFuture = Box<dyn Future<Output = CacheReadOptionalResult>>;
 
 impl CacheRead {
     pub fn acquire_meta(shard: u8, key: &str, method: &Method) -> CacheReadResultFuture {
diff --git a/src/proxy/serve.rs b/src/proxy/serve.rs
index eb14552..5ed8127 100644
--- a/src/proxy/serve.rs
+++ b/src/proxy/serve.rs
@@ -5,7 +5,7 @@
 // License: Mozilla Public License v2.0 (MPL v2.0)
 
 use futures::future::{self, Future};
-use headers::{ETag, IfNoneMatch, Origin};
+use headers::{ETag, IfNoneMatch, Origin, HeaderValue};
 use httparse;
 use hyper::{http, Body, Error, HeaderMap, Method, StatusCode, Uri};
 use hyper::{Request, Response};
@@ -25,12 +25,12 @@ const CACHED_PARSE_MAX_HEADERS: usize = 100;
 
 type ProxyServeResult = Result<(String, Option<String>), ()>;
 
-type ProxyServeResultFuture = dyn Future<Output = Response<Vec<u8>>>;
+type ProxyServeResultFuture = Box<dyn Future<Output = Response<Body>>>;
 
-pub type ProxyServeResponseFuture = dyn Future<Output = Response<Vec<u8>>>;
+pub type ProxyServeResponseFuture = Box<dyn Future<Output = Result<Response<Body>, hyper::Error>>>;
 
 impl ProxyServe {
-    pub fn handle(req: Request<Vec<u8>>) -> ProxyServeResponseFuture {
+    pub fn handle(req: Request<Body>) -> ProxyServeResponseFuture {
         info!("handled request: {} on {}", req.method(), req.path());
 
         match *req.method() {
@@ -45,11 +45,11 @@ impl ProxyServe {
         }
     }
 
-    fn accept(req: Request<Vec<u8>>) -> ProxyServeResponseFuture {
+    fn accept(req: Request<Body>) -> ProxyServeResponseFuture {
         Self::tunnel(req)
     }
 
-    fn reject(req: Request<Vec<u8>>, status: StatusCode) -> ProxyServeResponseFuture {
+    fn reject(req: Request<Body>, status: StatusCode) -> ProxyServeResponseFuture {
         let mut headers = HeaderMap::new();
 
         headers.set::<HeaderBloomStatus>(HeaderBloomStatus(HeaderBloomStatusValue::Reject));
@@ -57,7 +57,7 @@ impl ProxyServe {
         Self::respond(req.method(), status, headers, format!("{status}"))
     }
 
-    fn tunnel(req: Request<Vec<u8>>) -> ProxyServeResponseFuture {
+    fn tunnel(req: Request<Body>) -> ProxyServeResponseFuture {
         let (method, uri, version, headers, body) = req.deconstruct();
         let (headers, auth, shard) = ProxyHeader::parse_from_request(headers);
 
@@ -86,7 +86,7 @@ impl ProxyServe {
                     Err(_) => Self::tunnel_over_proxy(
                         shard, ns, ns_mask, auth_hash, method, &uri, version, &headers, body,
                     ),
-                }),
+                })
         )
     }
 
@@ -350,7 +350,7 @@ impl ProxyServe {
     }
 
     fn fingerprint_etag(fingerprint: String) -> ETag {
-        ETag::new(false, fingerprint)
+        fingerprint.parse::<headers::ETag>().unwrap()
     }
 
     fn respond(
@@ -360,13 +360,22 @@ impl ProxyServe {
         body_string: String,
     ) -> ProxyServeResponseFuture {
         Box::new(future::ok(match method {
-            &Method::Get | &Method::Post | &Method::Patch | &Method::Put | &Method::Delete => {
-                Response::new()
-                    .with_status(status)
-                    .with_headers(headers)
-                    .with_body(body_string)
+            &Method::GET | &Method::POST | &Method::PATCH | &Method::PUT | &Method::DELETE => {
+                let builder = Response::builder()
+                    .status(status);
+                let mut builder_headers = builder.headers_mut();
+                builder_headers = Some(&mut headers);
+                // Fix me
+                builder.body(Body::from(body_string)).unwrap()
+
             }
-            _ => Response::new().with_status(status).with_headers(headers),
+            _ => {
+                let builder = Response::builder().status(status);
+                let mut builder_headers = builder.headers_mut();
+                builder_headers = Some(&mut headers);
+                // Fix me
+                builder.body(Body::empty()).unwrap()
+            },
         }))
     }
 }
diff --git a/src/proxy/tunnel.rs b/src/proxy/tunnel.rs
index 00d465b..b00cd30 100644
--- a/src/proxy/tunnel.rs
+++ b/src/proxy/tunnel.rs
@@ -25,12 +25,11 @@ thread_local! {
 
 pub struct ProxyTunnel;
 
-pub type ProxyTunnelFuture = dyn Future<Output = Response<Vec<u8>>>;
+pub type ProxyTunnelFuture = Box<dyn Future<Output = Response<Vec<u8>>>>;
 
 fn make_client() -> Client<HttpConnector> {
-    Client::configure()
-        .keep_alive(true)
-        .keep_alive_timeout(Some(Duration::from_secs(CLIENT_KEEP_ALIVE_TIMEOUT_SECONDS)))
+    Client::builder()
+        .pool_idle_timeout(Some(Duration::from_secs(CLIENT_KEEP_ALIVE_TIMEOUT_SECONDS)))
         .build(
             &LISTEN_REMOTE
                 .lock()
@@ -71,7 +70,7 @@ fn map_shards() -> [Option<Uri>; MAX_SHARDS as usize] {
 }
 
 impl ProxyTunnel {
-    pub fn run(
+    pub async fn run(
         method: &Method,
         uri: &Uri,
         headers: &HeaderMap,
@@ -114,7 +113,7 @@ impl ProxyTunnel {
                                 _ => {}
                             }
 
-                            TUNNEL_CLIENT.with(|client| Box::new(client.request(tunnel_req)))
+                            TUNNEL_CLIENT.with(|client| Box::new(client.request(tunnel_req).into().await))
                         }
                         Err(err) => Box::new(future::err(Error::Uri(err))),
                     }
diff --git a/src/server/handle.rs b/src/server/handle.rs
index 7a308b4..0ee2245 100644
--- a/src/server/handle.rs
+++ b/src/server/handle.rs
@@ -4,20 +4,14 @@
 // Copyright: 2017, Valerian Saliou <valerian@valeriansaliou.name>
 // License: Mozilla Public License v2.0 (MPL v2.0)
 
-use hyper::{http::Request, http::Response, service::Service};
+use hyper::{http::Request, http::Response, service::Service, Body};
 
 use crate::proxy::serve::{ProxyServe, ProxyServeResponseFuture};
 
 pub struct ServerRequestHandle;
 
-impl Service<Request<Vec<u8>>> for ServerRequestHandle {
-    type Response = Response<Vec<u8>>;
-    type Error = hyper::Error;
-    type Future = ProxyServeResponseFuture;
 
-    fn call(&self, req: Request<Vec<u8>>) -> ProxyServeResponseFuture {
-        debug!("called proxy serve");
-
-        ProxyServe::handle(req)
-    }
+pub async fn server_handler(req: Request<Body>) -> Result<Response<Body>, hyper::Error> {
+    debug!("called proxy serve");
+    ProxyServe::handle(req)
 }
diff --git a/src/server/listen.rs b/src/server/listen.rs
index 1bc1a91..c538484 100644
--- a/src/server/listen.rs
+++ b/src/server/listen.rs
@@ -4,12 +4,13 @@
 // Copyright: 2017, Valerian Saliou <valerian@valeriansaliou.name>
 // License: Mozilla Public License v2.0 (MPL v2.0)
 
-use hyper::server::conn::Http;
+use hyper::server::Server;
+use hyper::service::{make_service_fn, service_fn};
 use std::cell::Cell;
 use std::sync::{Arc, Mutex};
 use tokio_core::reactor::Remote;
 
-use super::handle::ServerRequestHandle;
+use super::handle::server_handler;
 use crate::APP_CONF;
 
 lazy_static! {
@@ -20,24 +21,22 @@ lazy_static! {
 pub struct ServerListen;
 
 impl ServerListen {
-    pub fn run() {
+    pub async fn run() {
         let addr = APP_CONF.server.inet;
-        let server = Http::new()
-            .bind(&addr, move || {
-                debug!("handled new request");
-
-                Ok(ServerRequestHandle)
-            })
-            .expect("error binding server");
+        let make_service = make_service_fn(|_conn| async {
+            Ok::<_, hyper::Error>(service_fn(server_handler))
+    });
+        let server = Server::bind(&addr)
+            .serve(make_service);
 
         // Assign remote, used later on by the proxy client
-        LISTEN_REMOTE
-            .lock()
-            .unwrap()
-            .set(Some(server.handle().remote().clone()));
+        // LISTEN_REMOTE
+        //     .lock()
+        //     .unwrap()
+        //     .set(Some(server.handle().remote().clone()));
 
-        info!("listening on http://{}", server.local_addr().unwrap());
+        info!("listening on http://{}", addr);
 
-        server.run().expect("error running server");
+        server.await.expect("error running server");
     }
 }
